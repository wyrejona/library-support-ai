<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Library Support AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Reusing your root variables and base styles */
        :root {
            --primary: #1a73e8;
            --primary-dark: #0d47a1;
            --secondary: #5f6368;
            --success: #34a853;
            --danger: #d93025;
            --warning: #f9ab00;
            --light: #f8f9fa;
            --dark: #202124;
            --gray: #dadce0;
            --gray-light: #f1f3f4;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
            --radius: 12px;
            --radius-sm: 8px;
            --transition: all 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: var(--dark);
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        header {
            background: white;
            border-radius: var(--radius);
            padding: 25px 40px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo { display: flex; align-items: center; gap: 15px; }
        .logo i { font-size: 2.5rem; color: var(--primary); }
        .logo h1 { font-size: 1.8rem; margin: 0; }

        /* Model selector styles */
        .model-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
        }

        .model-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .model-label {
            font-size: 0.9rem;
            color: var(--secondary);
            min-width: 120px;
            font-weight: 500;
        }

        select {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid var(--gray);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            background: white;
            color: var(--dark);
            transition: var(--transition);
            cursor: pointer;
        }

        select:hover {
            border-color: var(--primary);
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2);
        }

        option {
            padding: 10px;
        }

        .btn-apply {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-apply:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-apply:disabled {
            background: var(--gray);
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Status indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-tag {
            background: var(--gray-light);
            padding: 8px 15px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1rem;
            color: var(--primary-dark);
        }

        /* Status message */
        .status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            display: none;
        }

        .status-success {
            background: rgba(52, 168, 83, 0.1);
            color: var(--success);
            border-left: 3px solid var(--success);
        }

        .status-error {
            background: rgba(217, 48, 37, 0.1);
            color: var(--danger);
            border-left: 3px solid var(--danger);
        }

        .status-info {
            background: rgba(26, 115, 232, 0.1);
            color: var(--primary);
            border-left: 3px solid var(--primary);
        }

        /* Dashboard Specifics */
        .welcome-section {
            text-align: center;
            padding: 40px 0;
        }

        .welcome-section h2 { font-size: 2.5rem; margin-bottom: 10px; color: var(--primary-dark); }
        .welcome-section p { font-size: 1.2rem; color: var(--secondary); }

        .grid-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }

        .menu-card {
            background: white;
            border-radius: var(--radius);
            padding: 40px;
            text-align: center;
            text-decoration: none;
            color: var(--dark);
            box-shadow: var(--shadow);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .menu-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }

        .menu-card i { font-size: 4rem; color: var(--primary); }
        .menu-card h3 { font-size: 1.5rem; margin: 0; }
        .menu-card p { color: var(--secondary); }

        /* Popular Models Section */
        .popular-models {
            background: white;
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .model-card {
            background: var(--gray-light);
            border-radius: var(--radius-sm);
            padding: 20px;
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
        }

        .model-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .model-card.recommended {
            border-left-color: var(--success);
            background: rgba(52, 168, 83, 0.05);
        }

        .model-card.fast {
            border-left-color: var(--warning);
        }

        .model-card.small {
            border-left-color: var(--secondary);
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .model-name {
            font-family: monospace;
            font-weight: bold;
            color: var(--dark);
        }

        .model-badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
        }

        .badge-recommended { background: var(--success); }
        .badge-fast { background: var(--warning); }
        .badge-small { background: var(--secondary); }

        .model-desc {
            font-size: 0.85rem;
            color: var(--secondary);
            margin-bottom: 10px;
        }

        .model-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--dark);
        }

        .model-action {
            text-align: center;
            margin-top: 10px;
        }

        .btn-use-model {
            padding: 5px 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .btn-use-model:hover {
            background: var(--primary-dark);
        }

        .model-status-box {
            background: white;
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            border-left: 5px solid var(--primary);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-weight: bold;
            color: var(--primary);
        }

        .test-links {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-test {
            padding: 8px 16px;
            border-radius: 20px;
            background: var(--gray-light);
            text-decoration: none;
            color: var(--secondary);
            font-size: 0.8rem;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn-test:hover { background: var(--gray); color: var(--dark); }

        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-quick {
            padding: 8px 15px;
            background: var(--gray-light);
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-quick:hover {
            background: var(--gray);
        }

        .btn-quick.primary {
            background: var(--primary);
            color: white;
        }

        .btn-quick.primary:hover {
            background: var(--primary-dark);
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--gray);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: var(--dark);
            color: white;
            text-align: left;
            border-radius: var(--radius-sm);
            padding: 15px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--dark) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .model-selector {
                min-width: auto;
            }
            
            .model-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .model-label {
                min-width: auto;
            }
            
            .welcome-section h2 {
                font-size: 2rem;
            }
            
            .models-grid {
                grid-template-columns: 1fr;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-brain"></i>
                <h1>Library Support AI</h1>
            </div>
            
            <div class="model-selector">
                <div class="model-group">
                    <span class="model-label">Chat Model:</span>
                    <select id="chatModelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                <div class="model-group">
                    <span class="model-label">Embedding Model:</span>
                    <select id="embeddingModelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                <div class="model-group">
                    <span class="model-label"></span>
                    <button id="applyBtn" class="btn-apply">
                        <i class="fas fa-sync-alt"></i> Apply Model Changes
                    </button>
                </div>
                <div id="statusMessage" class="status-message"></div>
            </div>
            
            <div class="status-indicator">
                <span class="model-tag" id="currentModelTag">Ollama: Loading...</span>
            </div>
        </header>

        <section class="welcome-section">
            <h2>Welcome!</h2>
            <p>System Reliability Dashboard for Library Research AI</p>
            <p><small>Change AI models using the selector above. This will update all system components.</small></p>
        </section>

        <div class="grid-menu">
            <a href="/chat" class="menu-card">
                <i class="fas fa-comments"></i>
                <h3>AI Chat Interface</h3>
                <p>Query your uploaded research papers using natural language.</p>
                <span style="color: var(--primary); font-weight: bold;">Open Chat →</span>
            </a>

            <a href="/files" class="menu-card">
                <i class="fas fa-file-invoice"></i>
                <h3>Document Manager</h3>
                <p>Upload, delete, and process PDF files for the vector store.</p>
                <span style="color: var(--primary); font-weight: bold;">Manage Files →</span>
            </a>
        </div>

        <!-- Popular Embedding Models Section -->
        <div class="popular-models">
            <div class="status-header">
                <i class="fas fa-star"></i> Popular Embedding Models for Ollama
            </div>
            <p style="color: var(--secondary); margin-bottom: 20px;">
                Select from these recommended models. Click "Use This Model" to apply.
            </p>
            
            <div class="models-grid" id="popularModelsGrid">
                <!-- Models will be populated by JavaScript -->
            </div>
            
            <div class="quick-actions">
                <button id="installMissingBtn" class="btn-quick primary">
                    <i class="fas fa-download"></i> Install Missing Models
                </button>
                <button id="refreshModelsListBtn" class="btn-quick">
                    <i class="fas fa-redo"></i> Refresh Available Models
                </button>
                <button id="showGuideBtn" class="btn-quick tooltip">
                    <i class="fas fa-question-circle"></i> What are Embedding Models?
                    <span class="tooltiptext">
                        <strong>Embedding Models</strong> convert text to numbers for semantic search.<br><br>
                        <strong>Purpose:</strong> Find relevant information in your PDFs<br>
                        <strong>Why it matters:</strong> Better embeddings = better search results<br>
                        <strong>Size matters:</strong> Larger models = more accurate but slower<br>
                        <strong>Recommendation:</strong> Use nomic-embed-text for most cases
                    </span>
                </button>
            </div>
        </div>

        <div class="model-status-box">
            <div class="status-header">
                <i class="fas fa-microchip"></i> AI Engine Status
            </div>
            <p><strong>Active Chat Model:</strong> <span class="model-tag" id="currentChatModel">Loading...</span></p>
            <p><strong>Active Embedding Model:</strong> <span class="model-tag" id="currentEmbeddingModel">Loading...</span></p>
            <p><strong>Architecture:</strong> RAG (Retrieval-Augmented Generation)</p>
            <p><strong>Provider:</strong> Local Ollama Instance</p>
            <p><strong>Vector Store:</strong> <span id="vectorStoreStatus">Checking...</span></p>
            <p><strong>Ollama Connection:</strong> <span id="ollamaStatus">Checking...</span></p>
            <p><strong>Available Memory:</strong> <span id="memoryStatus">Checking...</span></p>
            
            <div class="test-links">
                <a href="/health" class="btn-test"><i class="fas fa-heartbeat"></i> System Health</a>
                <a href="/api/files" class="btn-test"><i class="fas fa-code"></i> Files JSON API</a>
                <a href="/config" class="btn-test"><i class="fas fa-cog"></i> Configuration</a>
                <button id="refreshModelsBtn" class="btn-test"><i class="fas fa-redo"></i> Refresh Models</button>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div id="loadingText" style="margin-left: 20px; font-weight: bold;"></div>
    </div>

    <script>
        // Popular embedding models with descriptions and dependencies
        const POPULAR_EMBEDDING_MODELS = [
            {
                name: "nomic-embed-text:latest",
                description: "Best all-around balance of accuracy and speed",
                category: "recommended",
                size: "~330MB",
                dimensions: 768,
                accuracy: "High",
                speed: "Fast",
                useCase: "Most documents, general purpose",
                ramRequired: "2GB+",
                pullCommand: "ollama pull nomic-embed-text"
            },
            {
                name: "mxbai-embed-large:latest",
                description: "Most accurate, best for complex documents",
                category: "accurate",
                size: "~1.4GB",
                dimensions: 1024,
                accuracy: "Very High",
                speed: "Medium",
                useCase: "Academic papers, technical docs",
                ramRequired: "4GB+",
                pullCommand: "ollama pull mxbai-embed-large"
            },
            {
                name: "all-minilm:latest",
                description: "Very fast, good for many simple documents",
                category: "fast",
                size: "~80MB",
                dimensions: 384,
                accuracy: "Good",
                speed: "Very Fast",
                useCase: "Many simple documents, fast search",
                ramRequired: "1GB+",
                pullCommand: "ollama pull all-minilm"
            },
            {
                name: "bge-small-en:latest",
                description: "Optimized for English text, efficient",
                category: "efficient",
                size: "~130MB",
                dimensions: 384,
                accuracy: "Good",
                speed: "Fast",
                useCase: "English documents, general purpose",
                ramRequired: "1.5GB+",
                pullCommand: "ollama pull bge-small-en"
            },
            {
                name: "e5-mistral:latest",
                description: "Based on Mistral, good for instruction following",
                category: "advanced",
                size: "~5GB",
                dimensions: 4096,
                accuracy: "Excellent",
                speed: "Slow",
                useCase: "Complex queries, instruction-based search",
                ramRequired: "8GB+",
                pullCommand: "ollama pull e5-mistral"
            },
            {
                name: "multilingual-e5:latest",
                description: "Supports multiple languages",
                category: "multilingual",
                size: "~2.3GB",
                dimensions: 1024,
                accuracy: "High",
                speed: "Medium",
                useCase: "Multilingual documents",
                ramRequired: "4GB+",
                pullCommand: "ollama pull multilingual-e5"
            }
        ];

        // Popular chat models
        const POPULAR_CHAT_MODELS = [
            {
                name: "qwen:0.5b",
                description: "Small, fast, efficient for basic tasks",
                size: "~300MB",
                ramRequired: "1GB+"
            },
            {
                name: "llama2:7b",
                description: "Good balance of capability and speed",
                size: "~4GB",
                ramRequired: "8GB+"
            },
            {
                name: "mistral:7b",
                description: "Excellent for reasoning tasks",
                size: "~4GB",
                ramRequired: "8GB+"
            },
            {
                name: "phi:latest",
                description: "Very fast, good for constrained environments",
                size: "~1.5GB",
                ramRequired: "4GB+"
            },
            {
                name: "gemma:2b",
                description: "Google's efficient model",
                size: "~1.5GB",
                ramRequired: "4GB+"
            }
        ];

        // Global variables
        let currentConfig = null;
        let availableModels = null;

        // DOM elements
        const chatModelSelect = document.getElementById('chatModelSelect');
        const embeddingModelSelect = document.getElementById('embeddingModelSelect');
        const applyBtn = document.getElementById('applyBtn');
        const statusMessage = document.getElementById('statusMessage');
        const currentModelTag = document.getElementById('currentModelTag');
        const currentChatModel = document.getElementById('currentChatModel');
        const currentEmbeddingModel = document.getElementById('currentEmbeddingModel');
        const vectorStoreStatus = document.getElementById('vectorStoreStatus');
        const ollamaStatus = document.getElementById('ollamaStatus');
        const memoryStatus = document.getElementById('memoryStatus');
        const refreshModelsBtn = document.getElementById('refreshModelsBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const popularModelsGrid = document.getElementById('popularModelsGrid');
        const installMissingBtn = document.getElementById('installMissingBtn');
        const refreshModelsListBtn = document.getElementById('refreshModelsListBtn');
        const showGuideBtn = document.getElementById('showGuideBtn');

        // Show loading overlay with custom text
        function showLoading(text = 'Loading...') {
            loadingText.textContent = text;
            loadingOverlay.style.display = 'flex';
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.style.display = 'none';
            loadingText.textContent = 'Loading...';
        }

        // Show status message
        function showStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            
            // Auto-hide success messages after 5 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
        }

        // Load configuration and available models
        async function loadConfiguration() {
            try {
                showLoading('Loading configuration...');
                
                // Load current configuration
                const configResponse = await fetch('/config');
                if (!configResponse.ok) {
                    throw new Error('Failed to load configuration');
                }
                
                const configData = await configResponse.json();
                currentConfig = configData;
                
                // Update UI with current configuration
                currentModelTag.textContent = `Ollama: ${configData.current.chat_model}`;
                currentChatModel.textContent = configData.current.chat_model;
                currentEmbeddingModel.textContent = configData.current.embedding_model;
                
                // Update selects with current values
                updateModelSelects(configData);
                
                // Populate popular models grid
                populatePopularModels(configData);
                
                // Check system status
                await checkSystemStatus();
                
            } catch (error) {
                console.error('Error loading configuration:', error);
                showStatus('Failed to load configuration: ' + error.message, 'error');
                currentModelTag.textContent = 'Ollama: Error';
                currentChatModel.textContent = 'Error loading model';
                currentEmbeddingModel.textContent = 'Error loading model';
            } finally {
                hideLoading();
            }
        }

        // Update model dropdowns with available models
        function updateModelSelects(configData) {
            availableModels = configData.available_models;
            
            // Update chat model select
            chatModelSelect.innerHTML = '';
            if (availableModels.chat_models && availableModels.chat_models.length > 0) {
                // Add popular models first
                const popularSection = document.createElement('optgroup');
                popularSection.label = 'Popular Models';
                POPULAR_CHAT_MODELS.forEach(model => {
                    if (availableModels.chat_models.includes(model.name)) {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.description})`;
                        if (model.name === configData.current.chat_model) {
                            option.selected = true;
                        }
                        popularSection.appendChild(option);
                    }
                });
                chatModelSelect.appendChild(popularSection);
                
                // Add all other models
                const otherSection = document.createElement('optgroup');
                otherSection.label = 'All Available Models';
                availableModels.chat_models.forEach(model => {
                    if (!POPULAR_CHAT_MODELS.some(m => m.name === model)) {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.chat_model) {
                            option.selected = true;
                        }
                        otherSection.appendChild(option);
                    }
                });
                chatModelSelect.appendChild(otherSection);
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No chat models available';
                chatModelSelect.appendChild(option);
                chatModelSelect.disabled = true;
            }
            
            // Update embedding model select
            embeddingModelSelect.innerHTML = '';
            if (availableModels.embedding_models && availableModels.embedding_models.length > 0) {
                // Add popular embedding models first
                const popularSection = document.createElement('optgroup');
                popularSection.label = 'Recommended Embedding Models';
                POPULAR_EMBEDDING_MODELS.forEach(model => {
                    if (availableModels.embedding_models.includes(model.name)) {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.description})`;
                        if (model.name === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        popularSection.appendChild(option);
                    }
                });
                embeddingModelSelect.appendChild(popularSection);
                
                // Add all other embedding models
                const otherSection = document.createElement('optgroup');
                otherSection.label = 'All Embedding Models';
                availableModels.embedding_models.forEach(model => {
                    if (!POPULAR_EMBEDDING_MODELS.some(m => m.name === model)) {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        otherSection.appendChild(option);
                    }
                });
                embeddingModelSelect.appendChild(otherSection);
            } else {
                // If no embedding models found, show all models
                if (availableModels.chat_models && availableModels.chat_models.length > 0) {
                    const allSection = document.createElement('optgroup');
                    allSection.label = 'All Available Models (Can be used for embedding)';
                    availableModels.chat_models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        allSection.appendChild(option);
                    });
                    embeddingModelSelect.appendChild(allSection);
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No models available';
                    embeddingModelSelect.appendChild(option);
                    embeddingModelSelect.disabled = true;
                }
            }
            
            // Enable apply button if we have models
            applyBtn.disabled = !availableModels || 
                (!availableModels.chat_models && !availableModels.embedding_models);
        }

        // Populate popular models grid
        function populatePopularModels(configData) {
            popularModelsGrid.innerHTML = '';
            
            POPULAR_EMBEDDING_MODELS.forEach(model => {
                const isAvailable = availableModels && 
                    (availableModels.embedding_models || []).includes(model.name);
                const isCurrent = configData.current.embedding_model === model.name;
                
                const modelCard = document.createElement('div');
                modelCard.className = `model-card ${model.category} ${isCurrent ? 'current' : ''}`;
                
                // Determine badge based on category
                let badgeClass = '';
                let badgeText = '';
                switch(model.category) {
                    case 'recommended':
                        badgeClass = 'badge-recommended';
                        badgeText = 'RECOMMENDED';
                        break;
                    case 'fast':
                        badgeClass = 'badge-fast';
                        badgeText = 'FAST';
                        break;
                    case 'small':
                        badgeClass = 'badge-small';
                        badgeText = 'SMALL';
                        break;
                    default:
                        badgeClass = 'badge-recommended';
                        badgeText = model.category.toUpperCase();
                }
                
                modelCard.innerHTML = `
                    <div class="model-header">
                        <div class="model-name">${model.name}</div>
                        <div class="model-badge ${badgeClass}">${badgeText}</div>
                    </div>
                    <div class="model-desc">${model.description}</div>
                    <div class="model-stats">
                        <span>Size: ${model.size}</span>
                        <span>Dim: ${model.dimensions}</span>
                        <span>RAM: ${model.ramRequired}</span>
                    </div>
                    <div class="model-stats">
                        <span>Accuracy: ${model.accuracy}</span>
                        <span>Speed: ${model.speed}</span>
                    </div>
                    <div class="model-action">
                        ${isAvailable ? 
                            `<button class="btn-use-model" onclick="useModel('${model.name}')" ${isCurrent ? 'disabled style="opacity:0.5"' : ''}>
                                ${isCurrent ? '✓ Current Model' : 'Use This Model'}
                            </button>` :
                            `<button class="btn-use-model" onclick="installModel('${model.name}', '${model.pullCommand}')" style="background: var(--warning);">
                                <i class="fas fa-download"></i> Install Model
                            </button>`
                        }
                    </div>
                `;
                
                popularModelsGrid.appendChild(modelCard);
            });
        }

        // Use a specific model
        async function useModel(modelName) {
            if (!modelName) return;
            
            // Set the embedding model select to this model
            embeddingModelSelect.value = modelName;
            
            // Enable apply button
            applyBtn.disabled = false;
            
            showStatus(`Selected model: ${modelName}. Click "Apply Model Changes" to use it.`, 'info');
            
            // Scroll to model selector
            document.querySelector('.model-selector').scrollIntoView({ behavior: 'smooth' });
        }

        // Install a model
        async function installModel(modelName, pullCommand) {
            if (!confirm(`Install ${modelName}?\n\nThis will run: ${pullCommand}\n\nThis may take several minutes depending on your internet speed.`)) {
                return;
            }
            
            try {
                showLoading(`Installing ${modelName}... This may take a few minutes.`);
                
                // Send request to install model
                const response = await fetch('/install-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: modelName,
                        pull_command: pullCommand
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showStatus(`Model ${modelName} installed successfully!`, 'success');
                    
                    // Refresh models list after installation
                    setTimeout(() => {
                        loadConfiguration();
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Failed to install model');
                }
                
            } catch (error) {
                console.error('Error installing model:', error);
                showStatus('Failed to install model: ' + error.message, 'error');
                
                // Provide manual instructions
                showStatus(`You can install manually: Open terminal and run: ${pullCommand}`, 'info');
            } finally {
                hideLoading();
            }
        }

        // Install missing popular models
        async function installMissingModels() {
            if (!availableModels || !availableModels.embedding_models) return;
            
            const missingModels = POPULAR_EMBEDDING_MODELS.filter(model => 
                !availableModels.embedding_models.includes(model.name)
            );
            
            if (missingModels.length === 0) {
                showStatus('All popular models are already installed!', 'info');
                return;
            }
            
            const modelList = missingModels.map(m => m.name).join('\n');
            if (!confirm(`Install ${missingModels.length} missing models?\n\n${modelList}\n\nThis may take 10-20 minutes depending on your internet speed.`)) {
                return;
            }
            
            try {
                showLoading(`Installing ${missingModels.length} models... This will take a while.`);
                
                // Install models sequentially
                for (const model of missingModels) {
                    loadingText.textContent = `Installing ${model.name}...`;
                    
                    const response = await fetch('/install-model', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            model: model.name,
                            pull_command: model.pullCommand
                        })
                    });
                    
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(`Failed to install ${model.name}: ${result.error || 'Unknown error'}`);
                    }
                    
                    // Wait a bit between installations
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                showStatus(`Successfully installed ${missingModels.length} models!`, 'success');
                
                // Refresh models list
                setTimeout(() => {
                    loadConfiguration();
                }, 2000);
                
            } catch (error) {
                console.error('Error installing models:', error);
                showStatus('Failed to install some models: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }

        // Apply model changes
        async function applyModelChanges() {
            const selectedChatModel = chatModelSelect.value;
            const selectedEmbeddingModel = embeddingModelSelect.value;
            
            // Validate selections
            if (!selectedChatModel || !selectedEmbeddingModel) {
                showStatus('Please select both a chat model and an embedding model', 'error');
                return;
            }
            
            if (selectedChatModel === currentConfig.current.chat_model && 
                selectedEmbeddingModel === currentConfig.current.embedding_model) {
                showStatus('No changes detected', 'info');
                return;
            }
            
            try {
                showLoading('Applying model changes...');
                applyBtn.disabled = true;
                applyBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Applying...';
                
                // Prepare update data
                const updateData = {};
                if (selectedChatModel !== currentConfig.current.chat_model) {
                    updateData.chat_model = selectedChatModel;
                }
                if (selectedEmbeddingModel !== currentConfig.current.embedding_model) {
                    updateData.embedding_model = selectedEmbeddingModel;
                }
                
                // Send update request
                const response = await fetch('/config/model', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updateData)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showStatus(result.message || 'Models updated successfully! System is reloading...', 'success');
                    
                    // Update UI with new values
                    currentModelTag.textContent = `Ollama: ${selectedChatModel}`;
                    currentChatModel.textContent = selectedChatModel;
                    currentEmbeddingModel.textContent = selectedEmbeddingModel;
                    
                    // Reload configuration after a short delay
                    setTimeout(() => {
                        loadConfiguration();
                    }, 2000);
                } else {
                    throw new Error(result.error || 'Failed to update models');
                }
                
            } catch (error) {
                console.error('Error applying model changes:', error);
                showStatus('Failed to update models: ' + error.message, 'error');
            } finally {
                applyBtn.disabled = false;
                applyBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Apply Model Changes';
                hideLoading();
            }
        }

        // Check system status
        async function checkSystemStatus() {
            try {
                // Check health
                const healthResponse = await fetch('/health');
                if (healthResponse.ok) {
                    const healthData = await healthResponse.json();
                    
                    // Update vector store status
                    vectorStoreStatus.textContent = healthData.vector_store_ready ? 
                        'Ready' : 'Not ready (run ingest)';
                    vectorStoreStatus.style.color = healthData.vector_store_ready ? 
                        'var(--success)' : 'var(--warning)';
                    
                    // Update Ollama status
                    ollamaStatus.textContent = healthData.ollama_connected ? 
                        'Connected ✓' : 'Disconnected ✗';
                    ollamaStatus.style.color = healthData.ollama_connected ? 
                        'var(--success)' : 'var(--danger)';
                    
                    // Check memory (if available)
                    if (healthData.memory_usage) {
                        memoryStatus.textContent = healthData.memory_usage;
                    }
                }
                
                // Check for memory info
                try {
                    const memoryInfo = await getMemoryInfo();
                    if (memoryInfo) {
                        memoryStatus.textContent = memoryInfo;
                    }
                } catch (e) {
                    console.log('Could not get memory info:', e);
                }
                
            } catch (error) {
                console.error('Error checking system status:', error);
                vectorStoreStatus.textContent = 'Error checking';
                ollamaStatus.textContent = 'Error checking';
                memoryStatus.textContent = 'Error checking';
            }
        }

        // Get memory information
        async function getMemoryInfo() {
            try {
                // Try to get system info
                if (navigator.deviceMemory) {
                    return `${navigator.deviceMemory}GB available`;
                }
                
                // Fallback: Check performance memory
                if (performance.memory) {
                    const mem = performance.memory;
                    const used = Math.round(mem.usedJSHeapSize / 1024 / 1024);
                    const total = Math.round(mem.totalJSHeapSize / 1024 / 1024);
                    return `${used}MB / ${total}MB used`;
                }
                
                return 'Unknown';
            } catch (e) {
                return 'Unknown';
            }
        }

        // Refresh available models
        async function refreshModels() {
            try {
                showLoading('Refreshing models list...');
                refreshModelsBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Refreshing...';
                refreshModelsListBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Refreshing...';
                
                // Reload configuration
                await loadConfiguration();
                
                showStatus('Models refreshed successfully!', 'success');
            } catch (error) {
                console.error('Error refreshing models:', error);
                showStatus('Failed to refresh models: ' + error.message, 'error');
            } finally {
                refreshModelsBtn.innerHTML = '<i class="fas fa-redo"></i> Refresh Models';
                refreshModelsListBtn.innerHTML = '<i class="fas fa-redo"></i> Refresh Available Models';
                hideLoading();
            }
        }

        // Add install-model endpoint to your FastAPI app (you'll need to add this)
        async function checkInstallEndpoint() {
            try {
                const response = await fetch('/install-model', { method: 'HEAD' });
                return response.ok;
            } catch {
                return false;
            }
        }

        // Event listeners
        applyBtn.addEventListener('click', applyModelChanges);
        refreshModelsBtn.addEventListener('click', refreshModels);
        refreshModelsListBtn.addEventListener('click', refreshModels);
        installMissingBtn.addEventListener('click', installMissingModels);

        // Model select change listeners
        chatModelSelect.addEventListener('change', () => {
            // Enable apply button if model changed
            if (currentConfig && chatModelSelect.value !== currentConfig.current.chat_model) {
                applyBtn.disabled = false;
            }
        });

        embeddingModelSelect.addEventListener('change', () => {
            // Enable apply button if model changed
            if (currentConfig && embeddingModelSelect.value !== currentConfig.current.embedding_model) {
                applyBtn.disabled = false;
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Check if install endpoint exists
            const hasInstallEndpoint = await checkInstallEndpoint();
            if (!hasInstallEndpoint) {
                installMissingBtn.disabled = true;
                installMissingBtn.title = "Install endpoint not available. Install models manually using 'ollama pull' command.";
                showStatus('Note: Install model feature requires backend setup. Install models manually using terminal.', 'info');
            }
            
            loadConfiguration();
            
            // Check for URL parameters (e.g., from redirect after update)
            const urlParams = new URLSearchParams(window.location.search);
            const updateStatus = urlParams.get('update');
            if (updateStatus === 'success') {
                showStatus('Models updated successfully!', 'success');
                // Remove parameter from URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        });

        // Auto-refresh status every 30 seconds
        setInterval(checkSystemStatus, 30000);
        
        // Expose functions to global scope for onclick handlers
        window.useModel = useModel;
        window.installModel = installModel;
    </script>
</body>
</html>
