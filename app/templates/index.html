<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Library Support AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Root variables and base styles */
        :root {
            --primary: #1a73e8;
            --primary-dark: #0d47a1;
            --secondary: #5f6368;
            --success: #34a853;
            --danger: #d93025;
            --warning: #f9ab00;
            --light: #f8f9fa;
            --dark: #202124;
            --gray: #dadce0;
            --gray-light: #f1f3f4;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
            --radius: 12px;
            --radius-sm: 8px;
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: var(--dark);
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        /* Header styles */
        header {
            background: white;
            border-radius: var(--radius);
            padding: 25px 40px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        .logo i { 
            font-size: 2.5rem; 
            color: var(--primary); 
        }
        .logo h1 { 
            font-size: 1.8rem; 
            margin: 0; 
        }

        /* Model selector styles */
        .model-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 300px;
            flex: 1;
        }

        .model-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .model-label {
            font-size: 0.9rem;
            color: var(--secondary);
            min-width: 120px;
            font-weight: 500;
        }

        select {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid var(--gray);
            border-radius: var(--radius-sm);
            font-size: 0.95rem;
            background: white;
            color: var(--dark);
            transition: var(--transition);
            cursor: pointer;
        }

        select:hover {
            border-color: var(--primary);
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2);
        }

        option {
            padding: 10px;
        }

        .btn-apply {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-apply:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-apply:disabled {
            background: var(--gray);
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Status indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-tag {
            background: var(--gray-light);
            padding: 8px 15px;
            border-radius: 20px;
            font-family: monospace;
            font-size: 1rem;
            color: var(--primary-dark);
            border: 1px solid var(--gray);
        }

        /* Status message */
        .status-message {
            margin-top: 10px;
            padding: 10px;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            display: none;
        }

        .status-success {
            background: rgba(52, 168, 83, 0.1);
            color: var(--success);
            border-left: 3px solid var(--success);
        }

        .status-error {
            background: rgba(217, 48, 37, 0.1);
            color: var(--danger);
            border-left: 3px solid var(--danger);
        }

        .status-info {
            background: rgba(26, 115, 232, 0.1);
            color: var(--primary);
            border-left: 3px solid var(--primary);
        }

        /* Dashboard Specifics */
        .welcome-section {
            text-align: center;
            padding: 40px 0;
        }

        .welcome-section h2 { 
            font-size: 2.5rem; 
            margin-bottom: 10px; 
            color: var(--primary-dark); 
        }
        .welcome-section p { 
            font-size: 1.2rem; 
            color: var(--secondary); 
        }

        .grid-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }

        .menu-card {
            background: white;
            border-radius: var(--radius);
            padding: 40px;
            text-align: center;
            text-decoration: none;
            color: var(--dark);
            box-shadow: var(--shadow);
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .menu-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            border-color: var(--primary);
        }

        .menu-card i { 
            font-size: 4rem; 
            color: var(--primary); 
        }
        .menu-card h3 { 
            font-size: 1.5rem; 
            margin: 0; 
        }
        .menu-card p { 
            color: var(--secondary); 
        }

        /* Popular Models Section */
        .popular-models {
            background: white;
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            margin-top: 20px;
        }

        .models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .model-card {
            background: var(--gray-light);
            border-radius: var(--radius-sm);
            padding: 20px;
            border-left: 4px solid var(--primary);
            transition: var(--transition);
            cursor: pointer;
            position: relative;
        }

        .model-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .model-card.recommended {
            border-left-color: var(--success);
            background: rgba(52, 168, 83, 0.05);
        }

        .model-card.accurate {
            border-left-color: #d93025;
            background: rgba(217, 48, 37, 0.05);
        }

        .model-card.fast {
            border-left-color: var(--warning);
            background: rgba(249, 171, 0, 0.05);
        }

        .model-card.efficient {
            border-left-color: #1a73e8;
            background: rgba(26, 115, 232, 0.05);
        }

        .model-card.advanced {
            border-left-color: #9c27b0;
            background: rgba(156, 39, 176, 0.05);
        }

        .model-card.multilingual {
            border-left-color: #009688;
            background: rgba(0, 150, 136, 0.05);
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .model-name {
            font-family: monospace;
            font-weight: bold;
            color: var(--dark);
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .model-badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            flex-shrink: 0;
        }

        .badge-recommended { background: var(--success); }
        .badge-accurate { background: #d93025; }
        .badge-fast { background: var(--warning); }
        .badge-efficient { background: #1a73e8; }
        .badge-advanced { background: #9c27b0; }
        .badge-multilingual { background: #009688; }

        .model-desc {
            font-size: 0.85rem;
            color: var(--secondary);
            margin-bottom: 10px;
            min-height: 40px;
        }

        .model-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--dark);
            margin-bottom: 5px;
        }

        .model-action {
            text-align: center;
            margin-top: 10px;
        }

        .btn-use-model {
            padding: 5px 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
        }

        .btn-use-model:hover {
            background: var(--primary-dark);
        }

        .btn-use-model:disabled {
            background: var(--success);
            cursor: default;
        }

        /* Status boxes */
        .model-status-box {
            background: white;
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            border-left: 5px solid var(--primary);
        }

        .system-status-box {
            background: white;
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            border-left: 5px solid var(--warning);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--primary);
            font-size: 1.1rem;
        }

        .system-status-box .status-header {
            color: var(--warning);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid var(--gray-light);
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
        }

        .status-value {
            font-weight: 600;
            color: var(--dark);
        }

        .status-value.success {
            color: var(--success);
        }

        .status-value.warning {
            color: var(--warning);
        }

        .status-value.error {
            color: var(--danger);
        }

        .test-links {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-test {
            padding: 8px 16px;
            border-radius: 20px;
            background: var(--gray-light);
            text-decoration: none;
            color: var(--secondary);
            font-size: 0.8rem;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 5px;
            border: none;
            cursor: pointer;
            font-family: inherit;
        }

        .btn-test:hover { 
            background: var(--gray); 
            color: var(--dark); 
        }

        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn-quick {
            padding: 8px 15px;
            background: var(--gray-light);
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-quick:hover {
            background: var(--gray);
        }

        .btn-quick.primary {
            background: var(--primary);
            color: white;
        }

        .btn-quick.primary:hover {
            background: var(--primary-dark);
        }

        /* Memory visualization */
        .memory-visualization {
            width: 100%;
            height: 20px;
            background: var(--gray-light);
            border-radius: var(--radius-sm);
            overflow: hidden;
            position: relative;
            margin: 10px 0;
            border: 1px solid var(--gray);
        }

        .memory-used {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            transition: width 0.5s ease;
            position: relative;
        }

        .memory-used.warning {
            background: linear-gradient(90deg, var(--warning), #ff8f00);
        }

        .memory-used.danger {
            background: linear-gradient(90deg, var(--danger), #c62828);
        }

        .memory-label {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            display: none;
            backdrop-filter: blur(3px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid var(--gray);
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: var(--dark);
            color: white;
            text-align: left;
            border-radius: var(--radius-sm);
            padding: 15px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            pointer-events: none;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--dark) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Progress overlay */
        .progress-overlay {
            background: white;
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            text-align: center;
            min-width: 400px;
            max-width: 90%;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background: var(--gray-light);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-dark));
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,255,255,0.3), 
                transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-percent {
            font-weight: bold;
            font-size: 1.2rem;
            margin: 10px 0;
            color: var(--primary);
        }

        .progress-message {
            color: var(--secondary);
            margin-bottom: 20px;
            min-height: 24px;
        }

        /* Task logs */
        .task-logs {
            max-height: 200px;
            overflow-y: auto;
            background: var(--gray-light);
            border-radius: var(--radius-sm);
            padding: 10px;
            margin-top: 15px;
            text-align: left;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 3px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        /* Resource indicators */
        .resource-indicators {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .resource-card {
            background: var(--gray-light);
            border-radius: var(--radius-sm);
            padding: 15px;
            text-align: center;
            border-top: 4px solid var(--primary);
        }

        .resource-card.cpu {
            border-top-color: var(--success);
        }

        .resource-card.memory {
            border-top-color: var(--primary);
        }

        .resource-card.disk {
            border-top-color: var(--warning);
        }

        .resource-card.tasks {
            border-top-color: var(--secondary);
        }

        .resource-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 5px 0;
        }

        .resource-label {
            font-size: 0.85rem;
            color: var(--secondary);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            header {
                flex-direction: column;
                align-items: stretch;
                padding: 20px;
            }
            
            .model-selector {
                min-width: auto;
            }
            
            .model-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .model-label {
                min-width: auto;
            }
            
            .welcome-section h2 {
                font-size: 2rem;
            }
            
            .models-grid {
                grid-template-columns: 1fr;
            }
            
            .grid-menu {
                grid-template-columns: 1fr;
            }
            
            .test-links {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn-test {
                justify-content: center;
            }
            
            .quick-actions {
                flex-direction: column;
            }
            
            .progress-overlay {
                min-width: 90%;
                margin: 10px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px 10px;
            }
            
            .welcome-section h2 {
                font-size: 1.8rem;
            }
            
            .menu-card {
                padding: 25px;
            }
            
            .model-status-box,
            .system-status-box,
            .popular-models {
                padding: 20px;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-brain"></i>
                <h1>Library Support AI</h1>
            </div>
            
            <div class="model-selector">
                <div class="model-group">
                    <span class="model-label">Chat Model:</span>
                    <select id="chatModelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                <div class="model-group">
                    <span class="model-label">Embedding Model:</span>
                    <select id="embeddingModelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                <div class="model-group">
                    <span class="model-label"></span>
                    <button id="applyBtn" class="btn-apply" disabled>
                        <i class="fas fa-sync-alt"></i> Apply Model Changes
                    </button>
                </div>
                <div id="statusMessage" class="status-message"></div>
            </div>
            
            <div class="status-indicator">
                <span class="model-tag" id="currentModelTag">Ollama: Loading...</span>
            </div>
        </header>

        <section class="welcome-section">
            <h2>Welcome!</h2>
            <p>System Reliability Dashboard for Library Research AI</p>
            <p><small>Change AI models using the selector above. This will update all system components.</small></p>
        </section>

        <!-- Resource Indicators -->
        <div class="resource-indicators">
            <div class="resource-card cpu">
                <div class="resource-value" id="cpuPercent">0%</div>
                <div class="resource-label">CPU Usage</div>
            </div>
            <div class="resource-card memory">
                <div class="resource-value" id="memoryPercent">0%</div>
                <div class="resource-label">Memory Used</div>
            </div>
            <div class="resource-card disk">
                <div class="resource-value" id="diskPercent">0%</div>
                <div class="resource-label">Disk Usage</div>
            </div>
            <div class="resource-card tasks">
                <div class="resource-value" id="activeTasksCount">0</div>
                <div class="resource-label">Active Tasks</div>
            </div>
        </div>

        <div class="grid-menu">
            <a href="/chat" class="menu-card">
                <i class="fas fa-comments"></i>
                <h3>AI Chat Interface</h3>
                <p>Query your uploaded research papers using natural language.</p>
                <span style="color: var(--primary); font-weight: bold;">Open Chat →</span>
            </a>

            <a href="/files" class="menu-card">
                <i class="fas fa-file-invoice"></i>
                <h3>Document Manager</h3>
                <p>Upload, delete, and process PDF files for the vector store.</p>
                <span style="color: var(--primary); font-weight: bold;">Manage Files →</span>
            </a>
        </div>

        <!-- Popular Embedding Models Section -->
        <div class="popular-models">
            <div class="status-header">
                <i class="fas fa-star"></i> Popular Embedding Models for Ollama
            </div>
            <p style="color: var(--secondary); margin-bottom: 20px;">
                Select from these recommended models. Click "Use This Model" to apply.
            </p>
            
            <div class="models-grid" id="popularModelsGrid">
                <!-- Models will be populated by JavaScript -->
            </div>
            
            <div class="quick-actions">
                <button id="installMissingBtn" class="btn-quick primary">
                    <i class="fas fa-download"></i> Install Missing Models
                </button>
                <button id="refreshModelsListBtn" class="btn-quick">
                    <i class="fas fa-redo"></i> Refresh Available Models
                </button>
                <button id="showGuideBtn" class="btn-quick tooltip">
                    <i class="fas fa-question-circle"></i> What are Embedding Models?
                    <span class="tooltiptext">
                        <strong>Embedding Models</strong> convert text to numbers for semantic search.<br><br>
                        <strong>Purpose:</strong> Find relevant information in your PDFs<br>
                        <strong>Why it matters:</strong> Better embeddings = better search results<br>
                        <strong>Size matters:</strong> Larger models = more accurate but slower<br>
                        <strong>Recommendation:</strong> Use nomic-embed-text for most cases
                    </span>
                </button>
            </div>
        </div>

        <!-- AI Engine Status -->
        <div class="model-status-box">
            <div class="status-header">
                <i class="fas fa-microchip"></i> AI Engine Status
            </div>
            
            <div class="status-item">
                <span class="status-label">Active Chat Model:</span>
                <span class="status-value" id="currentChatModel">Loading...</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Active Embedding Model:</span>
                <span class="status-value" id="currentEmbeddingModel">Loading...</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Architecture:</span>
                <span class="status-value">RAG (Retrieval-Augmented Generation)</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Provider:</span>
                <span class="status-value">Local Ollama Instance</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Vector Store:</span>
                <span class="status-value" id="vectorStoreStatus">Checking...</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Ollama Connection:</span>
                <span class="status-value" id="ollamaStatus">Checking...</span>
            </div>
            
            <div class="test-links">
                <a href="/health" class="btn-test"><i class="fas fa-heartbeat"></i> System Health</a>
                <a href="/api/files" class="btn-test"><i class="fas fa-code"></i> Files JSON API</a>
                <a href="/config" class="btn-test"><i class="fas fa-cog"></i> Configuration</a>
                <button id="refreshModelsBtn" class="btn-test"><i class="fas fa-redo"></i> Refresh Models</button>
                <button id="reindexBtn" class="btn-test"><i class="fas fa-sync-alt"></i> Reindex Documents</button>
            </div>
        </div>

        <!-- System Resources -->
        <div class="system-status-box">
            <div class="status-header">
                <i class="fas fa-tachometer-alt"></i> System Resources
            </div>
            
            <div class="status-item">
                <span class="status-label">Memory Usage:</span>
                <span class="status-value" id="memoryText">Loading...</span>
            </div>
            
            <div class="memory-visualization">
                <div class="memory-used" id="memoryBar"></div>
                <div class="memory-label" id="memoryLabel"></div>
            </div>
            
            <div class="status-item">
                <span class="status-label">CPU Usage:</span>
                <span class="status-value" id="cpuText">Loading...</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Disk Usage:</span>
                <span class="status-value" id="diskText">Loading...</span>
            </div>
            
            <div class="status-item">
                <span class="status-label">Active Tasks:</span>
                <span class="status-value" id="tasksText">0</span>
            </div>
            
            <div class="quick-actions">
                <button id="refreshResourcesBtn" class="btn-quick">
                    <i class="fas fa-redo"></i> Refresh Resources
                </button>
                <button id="viewDetailedBtn" class="btn-quick" onclick="showDetailedMetrics()">
                    <i class="fas fa-chart-bar"></i> Detailed Metrics
                </button>
                <button id="viewTasksBtn" class="btn-quick" onclick="showActiveTasks()">
                    <i class="fas fa-tasks"></i> View Active Tasks
                </button>
            </div>
        </div>
    </div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div id="loadingText" style="margin-top: 20px; font-weight: bold; font-size: 1.1rem;"></div>
    </div>

    <!-- Progress overlay (for task monitoring) -->
    <div class="loading-overlay" id="progressOverlay">
        <div class="progress-overlay">
            <div class="loading-spinner"></div>
            <h3 id="progressTitle">Processing...</h3>
            <div class="progress-message" id="progressMessage">Starting task...</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-percent" id="progressPercent">0%</div>
            <div class="task-logs" id="taskLogs"></div>
            <button id="cancelTaskBtn" class="btn-quick" style="margin-top: 20px;">
                <i class="fas fa-times"></i> Cancel Task
            </button>
        </div>
    </div>

    <script>
        // Popular embedding models with descriptions
        const POPULAR_EMBEDDING_MODELS = [
            {
                name: "nomic-embed-text:latest",
                description: "Best all-around balance of accuracy and speed",
                category: "recommended",
                size: "~330MB",
                dimensions: 768,
                accuracy: "High",
                speed: "Fast",
                useCase: "Most documents, general purpose",
                ramRequired: "2GB+",
                pullCommand: "ollama pull nomic-embed-text"
            },
            {
                name: "mxbai-embed-large:latest",
                description: "Most accurate, best for complex documents",
                category: "accurate",
                size: "~1.4GB",
                dimensions: 1024,
                accuracy: "Very High",
                speed: "Medium",
                useCase: "Academic papers, technical docs",
                ramRequired: "4GB+",
                pullCommand: "ollama pull mxbai-embed-large"
            },
            {
                name: "all-minilm:latest",
                description: "Very fast, good for many simple documents",
                category: "fast",
                size: "~80MB",
                dimensions: 384,
                accuracy: "Good",
                speed: "Very Fast",
                useCase: "Many simple documents, fast search",
                ramRequired: "1GB+",
                pullCommand: "ollama pull all-minilm"
            },
            {
                name: "bge-small-en:latest",
                description: "Optimized for English text, efficient",
                category: "efficient",
                size: "~130MB",
                dimensions: 384,
                accuracy: "Good",
                speed: "Fast",
                useCase: "English documents, general purpose",
                ramRequired: "1.5GB+",
                pullCommand: "ollama pull bge-small-en"
            },
            {
                name: "e5-mistral:latest",
                description: "Based on Mistral, good for instruction following",
                category: "advanced",
                size: "~5GB",
                dimensions: 4096,
                accuracy: "Excellent",
                speed: "Slow",
                useCase: "Complex queries, instruction-based search",
                ramRequired: "8GB+",
                pullCommand: "ollama pull e5-mistral"
            },
            {
                name: "multilingual-e5:latest",
                description: "Supports multiple languages",
                category: "multilingual",
                size: "~2.3GB",
                dimensions: 1024,
                accuracy: "High",
                speed: "Medium",
                useCase: "Multilingual documents",
                ramRequired: "4GB+",
                pullCommand: "ollama pull multilingual-e5"
            }
        ];

        // Popular chat models
        const POPULAR_CHAT_MODELS = [
            {
                name: "qwen:0.5b",
                description: "Small, fast, efficient for basic tasks",
                size: "~300MB",
                ramRequired: "1GB+"
            },
            {
                name: "llama2:7b",
                description: "Good balance of capability and speed",
                size: "~4GB",
                ramRequired: "8GB+"
            },
            {
                name: "mistral:7b",
                description: "Excellent for reasoning tasks",
                size: "~4GB",
                ramRequired: "8GB+"
            },
            {
                name: "phi:latest",
                description: "Very fast, good for constrained environments",
                size: "~1.5GB",
                ramRequired: "4GB+"
            },
            {
                name: "gemma:2b",
                description: "Google's efficient model",
                size: "~1.5GB",
                ramRequired: "4GB+"
            },
            {
                name: "mixtral:8x7b",
                description: "Powerful mixture of experts model",
                size: "~25GB",
                ramRequired: "32GB+"
            }
        ];

        // Global variables
        let currentConfig = null;
        let availableModels = null;
        let currentTaskMonitor = null;
        let taskPollingInterval = null;

        // DOM elements
        const chatModelSelect = document.getElementById('chatModelSelect');
        const embeddingModelSelect = document.getElementById('embeddingModelSelect');
        const applyBtn = document.getElementById('applyBtn');
        const statusMessage = document.getElementById('statusMessage');
        const currentModelTag = document.getElementById('currentModelTag');
        const currentChatModel = document.getElementById('currentChatModel');
        const currentEmbeddingModel = document.getElementById('currentEmbeddingModel');
        const vectorStoreStatus = document.getElementById('vectorStoreStatus');
        const ollamaStatus = document.getElementById('ollamaStatus');
        const memoryText = document.getElementById('memoryText');
        const cpuText = document.getElementById('cpuText');
        const diskText = document.getElementById('diskText');
        const tasksText = document.getElementById('tasksText');
        const memoryBar = document.getElementById('memoryBar');
        const memoryLabel = document.getElementById('memoryLabel');
        const refreshModelsBtn = document.getElementById('refreshModelsBtn');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const popularModelsGrid = document.getElementById('popularModelsGrid');
        const installMissingBtn = document.getElementById('installMissingBtn');
        const refreshModelsListBtn = document.getElementById('refreshModelsListBtn');
        const showGuideBtn = document.getElementById('showGuideBtn');
        const refreshResourcesBtn = document.getElementById('refreshResourcesBtn');
        const reindexBtn = document.getElementById('reindexBtn');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressTitle = document.getElementById('progressTitle');
        const progressMessage = document.getElementById('progressMessage');
        const progressBar = document.getElementById('progressBar');
        const progressPercent = document.getElementById('progressPercent');
        const taskLogs = document.getElementById('taskLogs');
        const cancelTaskBtn = document.getElementById('cancelTaskBtn');
        const cpuPercent = document.getElementById('cpuPercent');
        const memoryPercent = document.getElementById('memoryPercent');
        const diskPercent = document.getElementById('diskPercent');
        const activeTasksCount = document.getElementById('activeTasksCount');

        // Show loading overlay
        function showLoading(text = 'Loading...') {
            loadingText.textContent = text;
            loadingOverlay.style.display = 'flex';
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.style.display = 'none';
            loadingText.textContent = 'Loading...';
        }

        // Show progress overlay
        function showProgress(title = 'Processing...') {
            progressTitle.textContent = title;
            progressOverlay.style.display = 'flex';
            taskLogs.innerHTML = '';
        }

        // Hide progress overlay
        function hideProgress() {
            progressOverlay.style.display = 'none';
            if (taskPollingInterval) {
                clearInterval(taskPollingInterval);
                taskPollingInterval = null;
            }
            currentTaskMonitor = null;
        }

        // Show status message
        function showStatus(message, type = 'info', duration = 5000) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            
            // Auto-hide success messages after duration
            if (type === 'success') {
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, duration);
            }
        }

        // Update progress display
        function updateProgress(progress, message, logs = []) {
            progressBar.style.width = `${progress}%`;
            progressPercent.textContent = `${progress}%`;
            progressMessage.textContent = message;
            
            // Update logs
            if (logs.length > 0) {
                taskLogs.innerHTML = logs.map(log => 
                    `<div class="log-entry">${log}</div>`
                ).join('');
                taskLogs.scrollTop = taskLogs.scrollHeight;
            }
        }

        // Check if server is responding
        async function checkServerStatus() {
            try {
                // Try to access a simple endpoint first
                const response = await fetch('/health', { 
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                return response.ok;
            } catch (error) {
                console.error('Server check failed:', error);
                return false;
            }
        }

        // Load configuration and available models
        async function loadConfiguration() {
            try {
                showLoading('Loading configuration...');
                
                // Check server status first
                const serverOk = await checkServerStatus();
                if (!serverOk) {
                    throw new Error('Server is not responding. Please check if the application is running.');
                }
                
                // Load current configuration
                const configResponse = await fetch('/config', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (!configResponse.ok) {
                    if (configResponse.status === 404) {
                        throw new Error('Configuration endpoint not found. The server may be starting up.');
                    }
                    throw new Error(`Failed to load configuration: ${configResponse.status}`);
                }
                
                currentConfig = await configResponse.json();
                
                // Update UI with current configuration
                currentModelTag.textContent = `Ollama: ${currentConfig.current.chat_model}`;
                currentChatModel.textContent = currentConfig.current.chat_model;
                currentEmbeddingModel.textContent = currentConfig.current.embedding_model;
                
                // Update selects with current values
                updateModelSelects(currentConfig);
                
                // Populate popular models grid
                populatePopularModels(currentConfig);
                
                // Check system status
                await checkSystemStatus();
                
                // Update system resources
                await updateSystemResources();
                
                // Check active tasks
                await checkActiveTasks();
                
                showStatus('Dashboard loaded successfully!', 'success', 3000);
                
            } catch (error) {
                console.error('Error loading configuration:', error);
                showStatus('Failed to load configuration: ' + error.message, 'error');
                currentModelTag.textContent = 'Ollama: Error';
                currentChatModel.textContent = 'Error loading model';
                currentEmbeddingModel.textContent = 'Error loading model';
                
                // Show helpful error message
                if (error.message.includes('Server is not responding')) {
                    showStatus('Server is not responding. Please check: 1) FastAPI is running, 2) Port 8000 is not in use, 3) Check server logs for errors.', 'error');
                }
            } finally {
                hideLoading();
            }
        }

        // Update model dropdowns with available models
        function updateModelSelects(configData) {
            availableModels = configData.available_models;
            
            // Update chat model select
            chatModelSelect.innerHTML = '';
            if (availableModels.chat_models && availableModels.chat_models.length > 0) {
                // Add popular models first
                const popularSection = document.createElement('optgroup');
                popularSection.label = 'Popular Models';
                POPULAR_CHAT_MODELS.forEach(model => {
                    if (availableModels.chat_models.includes(model.name)) {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.description})`;
                        if (model.name === configData.current.chat_model) {
                            option.selected = true;
                        }
                        popularSection.appendChild(option);
                    }
                });
                chatModelSelect.appendChild(popularSection);
                
                // Add all other models
                const otherSection = document.createElement('optgroup');
                otherSection.label = 'All Available Models';
                availableModels.chat_models.forEach(model => {
                    if (!POPULAR_CHAT_MODELS.some(m => m.name === model)) {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.chat_model) {
                            option.selected = true;
                        }
                        otherSection.appendChild(option);
                    }
                });
                chatModelSelect.appendChild(otherSection);
            } else {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No chat models available';
                chatModelSelect.appendChild(option);
                chatModelSelect.disabled = true;
            }
            
            // Update embedding model select
            embeddingModelSelect.innerHTML = '';
            if (availableModels.embedding_models && availableModels.embedding_models.length > 0) {
                // Add popular embedding models first
                const popularSection = document.createElement('optgroup');
                popularSection.label = 'Recommended Embedding Models';
                POPULAR_EMBEDDING_MODELS.forEach(model => {
                    if (availableModels.embedding_models.includes(model.name)) {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = `${model.name} (${model.description})`;
                        if (model.name === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        popularSection.appendChild(option);
                    }
                });
                embeddingModelSelect.appendChild(popularSection);
                
                // Add all other embedding models
                const otherSection = document.createElement('optgroup');
                otherSection.label = 'All Embedding Models';
                availableModels.embedding_models.forEach(model => {
                    if (!POPULAR_EMBEDDING_MODELS.some(m => m.name === model)) {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        otherSection.appendChild(option);
                    }
                });
                embeddingModelSelect.appendChild(otherSection);
            } else {
                // If no embedding models found, show all models
                if (availableModels.chat_models && availableModels.chat_models.length > 0) {
                    const allSection = document.createElement('optgroup');
                    allSection.label = 'All Available Models (Can be used for embedding)';
                    availableModels.chat_models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === configData.current.embedding_model) {
                            option.selected = true;
                        }
                        allSection.appendChild(option);
                    });
                    embeddingModelSelect.appendChild(allSection);
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No models available';
                    embeddingModelSelect.appendChild(option);
                    embeddingModelSelect.disabled = true;
                }
            }
            
            // Enable apply button if we have models
            applyBtn.disabled = !availableModels || 
                (!availableModels.chat_models && !availableModels.embedding_models);
        }

        // Populate popular models grid
        function populatePopularModels(configData) {
            popularModelsGrid.innerHTML = '';
            
            POPULAR_EMBEDDING_MODELS.forEach(model => {
                const isAvailable = availableModels && 
                    (availableModels.embedding_models || []).includes(model.name);
                const isCurrent = configData.current.embedding_model === model.name;
                
                const modelCard = document.createElement('div');
                modelCard.className = `model-card ${model.category} ${isCurrent ? 'current' : ''}`;
                
                // Determine badge based on category
                let badgeClass = '';
                let badgeText = '';
                switch(model.category) {
                    case 'recommended':
                        badgeClass = 'badge-recommended';
                        badgeText = 'RECOMMENDED';
                        break;
                    case 'accurate':
                        badgeClass = 'badge-accurate';
                        badgeText = 'ACCURATE';
                        break;
                    case 'fast':
                        badgeClass = 'badge-fast';
                        badgeText = 'FAST';
                        break;
                    case 'efficient':
                        badgeClass = 'badge-efficient';
                        badgeText = 'EFFICIENT';
                        break;
                    case 'advanced':
                        badgeClass = 'badge-advanced';
                        badgeText = 'ADVANCED';
                        break;
                    case 'multilingual':
                        badgeClass = 'badge-multilingual';
                        badgeText = 'MULTILINGUAL';
                        break;
                    default:
                        badgeClass = 'badge-recommended';
                        badgeText = model.category.toUpperCase();
                }
                
                modelCard.innerHTML = `
                    <div class="model-header">
                        <div class="model-name" title="${model.name}">${model.name}</div>
                        <div class="model-badge ${badgeClass}">${badgeText}</div>
                    </div>
                    <div class="model-desc">${model.description}</div>
                    <div class="model-stats">
                        <span>Size: ${model.size}</span>
                        <span>Dim: ${model.dimensions}</span>
                        <span>RAM: ${model.ramRequired}</span>
                    </div>
                    <div class="model-stats">
                        <span>Accuracy: ${model.accuracy}</span>
                        <span>Speed: ${model.speed}</span>
                    </div>
                    <div class="model-action">
                        ${isAvailable ? 
                            `<button class="btn-use-model" onclick="useModel('${model.name}')" ${isCurrent ? 'disabled' : ''}>
                                ${isCurrent ? '<i class="fas fa-check"></i> Current Model' : 'Use This Model'}
                            </button>` :
                            `<button class="btn-use-model" onclick="installModel('${model.name}', '${model.pullCommand}')" style="background: var(--warning);">
                                <i class="fas fa-download"></i> Install Model
                            </button>`
                        }
                    </div>
                `;
                
                popularModelsGrid.appendChild(modelCard);
            });
        }

        // Use a specific model
        async function useModel(modelName) {
            if (!modelName) return;
            
            // Set the embedding model select to this model
            embeddingModelSelect.value = modelName;
            
            // Enable apply button
            applyBtn.disabled = false;
            
            showStatus(`Selected model: ${modelName}. Click "Apply Model Changes" to use it.`, 'info');
            
            // Scroll to model selector
            document.querySelector('.model-selector').scrollIntoView({ behavior: 'smooth' });
        }

        // Install a model
        async function installModel(modelName, pullCommand) {
            if (!confirm(`Install ${modelName}?\n\nThis will run: ${pullCommand}\n\nThis may take several minutes depending on your internet speed and model size.`)) {
                return;
            }
            
            try {
                showProgress(`Installing ${modelName}`);
                
                // Send request to install model
                const response = await fetch('/install-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: modelName
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to start installation');
                }
                
                const result = await response.json();
                
                if (result.task_id) {
                    // Start monitoring the task
                    monitorTask(result.task_id, modelName);
                } else {
                    throw new Error('No task ID returned');
                }
                
            } catch (error) {
                console.error('Error installing model:', error);
                hideProgress();
                showStatus('Failed to install model: ' + error.message, 'error');
                
                // Provide manual instructions
                showStatus(`You can install manually: Open terminal and run: ${pullCommand}`, 'info');
            }
        }

        // Install missing popular models
        async function installMissingModels() {
            if (!availableModels || !availableModels.embedding_models) return;
            
            const missingModels = POPULAR_EMBEDDING_MODELS.filter(model => 
                !availableModels.embedding_models.includes(model.name)
            );
            
            if (missingModels.length === 0) {
                showStatus('All popular models are already installed!', 'info');
                return;
            }
            
            const modelList = missingModels.map(m => m.name).join('\n');
            if (!confirm(`Install ${missingModels.length} missing models?\n\n${modelList}\n\nThis may take 10-20 minutes depending on your internet speed and model sizes.`)) {
                return;
            }
            
            try {
                showProgress(`Installing ${missingModels.length} models`);
                
                // Start with first model
                const firstModel = missingModels[0];
                const response = await fetch('/install-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: firstModel.name
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to start installation');
                }
                
                const result = await response.json();
                
                if (result.task_id) {
                    monitorTask(result.task_id, `Installing ${missingModels.length} models`);
                }
                
            } catch (error) {
                console.error('Error installing models:', error);
                hideProgress();
                showStatus('Failed to install models: ' + error.message, 'error');
            }
        }

        // Monitor task progress
        async function monitorTask(taskId, taskName = 'Task') {
            if (!taskId) return;
            
            showProgress(taskName);
            currentTaskMonitor = taskId;
            
            // Set up polling for task progress
            taskPollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/tasks/progress/${taskId}`, {
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            updateProgress(0, `Task ${taskId} not found`, [`Task ${taskId} was not found on the server`]);
                            clearInterval(taskPollingInterval);
                            setTimeout(() => {
                                hideProgress();
                                showStatus(`Task ${taskName} was not found on server`, 'error');
                            }, 2000);
                            return;
                        }
                        throw new Error(`Failed to get task progress: ${response.status}`);
                    }
                    
                    const progress = await response.json();
                    
                    // Update progress display
                    updateProgress(
                        progress.progress || 0,
                        progress.message || 'Processing...',
                        progress.logs || []
                    );
                    
                    // Check if task is completed
                    if (progress.status === 'completed') {
                        clearInterval(taskPollingInterval);
                        setTimeout(() => {
                            hideProgress();
                            showStatus(`${taskName} completed successfully!`, 'success');
                            // Refresh configuration to update available models
                            loadConfiguration();
                        }, 2000);
                    } else if (progress.status === 'failed') {
                        clearInterval(taskPollingInterval);
                        hideProgress();
                        showStatus(`${taskName} failed: ${progress.message}`, 'error');
                    } else if (progress.status === 'cancelled') {
                        clearInterval(taskPollingInterval);
                        hideProgress();
                        showStatus(`${taskName} cancelled`, 'info');
                    }
                    
                } catch (error) {
                    console.error('Error monitoring task:', error);
                    updateProgress(0, 'Error monitoring task', [`Error: ${error.message}`]);
                }
            }, 1000);
            
            // Set up cancel button handler
            cancelTaskBtn.onclick = async () => {
                if (confirm('Are you sure you want to cancel this task?')) {
                    try {
                        const response = await fetch(`/tasks/${taskId}`, {
                            method: 'DELETE'
                        });
                        
                        if (response.ok) {
                            showStatus('Task cancellation requested', 'info');
                        }
                    } catch (error) {
                        console.error('Error cancelling task:', error);
                        showStatus('Failed to cancel task: ' + error.message, 'error');
                    }
                }
            };
        }

        // Apply model changes
        async function applyModelChanges() {
            const selectedChatModel = chatModelSelect.value;
            const selectedEmbeddingModel = embeddingModelSelect.value;
            
            // Validate selections
            if (!selectedChatModel || !selectedEmbeddingModel) {
                showStatus('Please select both a chat model and an embedding model', 'error');
                return;
            }
            
            if (selectedChatModel === currentConfig.current.chat_model && 
                selectedEmbeddingModel === currentConfig.current.embedding_model) {
                showStatus('No changes detected', 'info');
                return;
            }
            
            try {
                showLoading('Applying model changes...');
                applyBtn.disabled = true;
                applyBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Applying...';
                
                // Prepare update data
                const updateData = {};
                if (selectedChatModel !== currentConfig.current.chat_model) {
                    updateData.chat_model = selectedChatModel;
                }
                if (selectedEmbeddingModel !== currentConfig.current.embedding_model) {
                    updateData.embedding_model = selectedEmbeddingModel;
                }
                
                // Send update request
                const response = await fetch('/config/model', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updateData)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    showStatus(result.message || 'Models updated successfully!', 'success');
                    
                    // Update UI with new values
                    currentModelTag.textContent = `Ollama: ${selectedChatModel}`;
                    currentChatModel.textContent = selectedChatModel;
                    currentEmbeddingModel.textContent = selectedEmbeddingModel;
                    
                    // Update current config
                    currentConfig.current.chat_model = selectedChatModel;
                    currentConfig.current.embedding_model = selectedEmbeddingModel;
                    
                    // Update model selects to show current selection
                    updateModelSelects(currentConfig);
                    
                } else {
                    throw new Error(result.error || 'Failed to update models');
                }
                
            } catch (error) {
                console.error('Error applying model changes:', error);
                showStatus('Failed to update models: ' + error.message, 'error');
            } finally {
                applyBtn.disabled = false;
                applyBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Apply Model Changes';
                hideLoading();
            }
        }

        // Check system status
        async function checkSystemStatus() {
            try {
                // Check health
                const healthResponse = await fetch('/health', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (healthResponse.ok) {
                    const healthData = await healthResponse.json();
                    
                    // Update vector store status
                    vectorStoreStatus.textContent = healthData.vector_store_ready ? 
                        'Ready ✓' : 'Not ready (run ingest)';
                    vectorStoreStatus.className = healthData.vector_store_ready ? 
                        'status-value success' : 'status-value warning';
                    
                    // Update Ollama status
                    ollamaStatus.textContent = healthData.ollama_connected ? 
                        'Connected ✓' : 'Disconnected ✗';
                    ollamaStatus.className = healthData.ollama_connected ? 
                        'status-value success' : 'status-value error';
                    
                    // Update memory status
                    if (healthData.memory_usage) {
                        memoryText.textContent = healthData.memory_usage;
                    }
                } else {
                    throw new Error(`Health check failed: ${healthResponse.status}`);
                }
                
            } catch (error) {
                console.error('Error checking system status:', error);
                vectorStoreStatus.textContent = 'Error checking';
                vectorStoreStatus.className = 'status-value error';
                ollamaStatus.textContent = 'Error checking';
                ollamaStatus.className = 'status-value error';
            }
        }

        // Update system resources
        async function updateSystemResources() {
            try {
                const response = await fetch('/system/status', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update memory visualization
                    const memPercent = data.memory.percent;
                    memoryBar.style.width = `${memPercent}%`;
                    memoryBar.className = memPercent > 90 ? 'memory-used danger' : 
                                        memPercent > 70 ? 'memory-used warning' : 'memory-used';
                    
                    memoryLabel.textContent = `${memPercent}% (${data.memory.available_gb}GB free)`;
                    memoryText.textContent = `${data.memory.percent}% - ${data.memory.available_gb}GB free of ${data.memory.total_gb}GB`;
                    memoryPercent.textContent = `${memPercent}%`;
                    
                    // Update CPU
                    const cpuPercentValue = data.cpu.percent;
                    cpuText.textContent = `${cpuPercentValue}%`;
                    cpuPercent.textContent = `${cpuPercentValue}%`;
                    
                    // Update disk
                    const diskPercentValue = data.disk.percent;
                    diskText.textContent = `${diskPercentValue}% - ${data.disk.free_gb}GB free of ${data.disk.total_gb}GB`;
                    diskPercent.textContent = `${diskPercentValue}%`;
                    
                    // Update tasks
                    const activeTasks = data.system.active_tasks || 0;
                    tasksText.textContent = activeTasks;
                    activeTasksCount.textContent = activeTasks;
                    
                } else {
                    console.warn('Failed to fetch system status:', response.status);
                }
            } catch (error) {
                console.error('Error updating system resources:', error);
                // Don't show error to user for auto-updates
            }
        }

        // Check active tasks
        async function checkActiveTasks() {
            try {
                const response = await fetch('/tasks/active', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    // Update task count
                    tasksText.textContent = data.active.length;
                    activeTasksCount.textContent = data.active.length;
                }
            } catch (error) {
                console.error('Error checking active tasks:', error);
            }
        }

        // Refresh available models
        async function refreshModels() {
            try {
                showLoading('Refreshing models list...');
                refreshModelsBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Refreshing...';
                refreshModelsListBtn.innerHTML = '<i class="fas fa-spinner loading"></i> Refreshing...';
                
                // Reload configuration
                await loadConfiguration();
                
                showStatus('Models refreshed successfully!', 'success');
            } catch (error) {
                console.error('Error refreshing models:', error);
                showStatus('Failed to refresh models: ' + error.message, 'error');
            } finally {
                refreshModelsBtn.innerHTML = '<i class="fas fa-redo"></i> Refresh Models';
                refreshModelsListBtn.innerHTML = '<i class="fas fa-redo"></i> Refresh Available Models';
                hideLoading();
            }
        }

        // Start reindexing
        async function startReindexing() {
            if (!confirm('Reindex all documents? This may take several minutes depending on the number of files.')) {
                return;
            }
            
            try {
                showLoading('Starting reindexing...');
                
                const response = await fetch('/tasks/start/reindex', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                if (response.ok) {
                    const result = await response.json();
                    hideLoading();
                    monitorTask(result.task_id, 'Reindexing Documents');
                } else {
                    throw new Error('Failed to start reindexing');
                }
            } catch (error) {
                hideLoading();
                showStatus('Failed to start reindexing: ' + error.message, 'error');
            }
        }

        // Show detailed metrics
        async function showDetailedMetrics() {
            try {
                showLoading('Loading detailed metrics...');
                
                const response = await fetch('/system/status', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    let details = `
                        <strong>System Metrics:</strong><br><br>
                        <strong>CPU:</strong><br>
                        - Usage: ${data.cpu.percent}%<br>
                        - Cores: ${data.cpu.cores}<br>
                        - Load Average: ${data.cpu.load_average.join(', ')}<br><br>
                        
                        <strong>Memory:</strong><br>
                        - Total: ${data.memory.total_gb}GB<br>
                        - Used: ${data.memory.used_gb}GB<br>
                        - Available: ${data.memory.available_gb}GB<br>
                        - Usage: ${data.memory.percent}%<br>
                        - Swap Used: ${data.memory.swap_used_gb}GB of ${data.memory.swap_total_gb}GB<br><br>
                        
                        <strong>Disk:</strong><br>
                        - Total: ${data.disk.total_gb}GB<br>
                        - Used: ${data.disk.used_gb}GB<br>
                        - Free: ${data.disk.free_gb}GB<br>
                        - Usage: ${data.disk.percent}%<br><br>
                        
                        <strong>Process:</strong><br>
                        - Memory: ${data.process.memory_mb}MB<br>
                        - CPU: ${data.process.cpu_percent}%<br>
                        - Threads: ${data.process.threads}<br><br>
                        
                        <strong>System:</strong><br>
                        - Active Tasks: ${data.system.active_tasks}<br>
                        - Ollama Connected: ${data.system.ollama_connected ? 'Yes' : 'No'}<br>
                        - Ollama Models: ${data.system.ollama_models_count}<br>
                        - Vector Store Ready: ${data.system.vector_store_ready ? 'Yes' : 'No'}<br>
                    `;
                    
                    hideLoading();
                    alert(details);
                }
            } catch (error) {
                hideLoading();
                showStatus('Failed to load detailed metrics: ' + error.message, 'error');
            }
        }

        // Show active tasks
        async function showActiveTasks() {
            try {
                showLoading('Loading active tasks...');
                
                const response = await fetch('/tasks/active', {
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    let tasksInfo = `<strong>Active Tasks (${data.active.length}):</strong><br><br>`;
                    
                    if (data.active.length === 0) {
                        tasksInfo += 'No active tasks<br><br>';
                    } else {
                        data.active.forEach(task => {
                            tasksInfo += `
                                <strong>${task.type.toUpperCase()}:</strong><br>
                                - ID: ${task.task_id}<br>
                                - Progress: ${task.progress}%<br>
                                - Status: ${task.message}<br>
                                - Started: ${new Date(task.start_time).toLocaleTimeString()}<br><br>
                            `;
                        });
                    }
                    
                    tasksInfo += `<strong>Recent Tasks (${data.recent.length}):</strong><br><br>`;
                    
                    if (data.recent.length === 0) {
                        tasksInfo += 'No recent tasks';
                    } else {
                        data.recent.forEach(task => {
                            tasksInfo += `
                                <strong>${task.type.toUpperCase()}:</strong><br>
                                - Status: ${task.status}<br>
                                - Progress: ${task.progress}%<br>
                                - Duration: ${task.duration ? Math.round(task.duration) + 's' : 'N/A'}<br><br>
                            `;
                        });
                    }
                    
                    hideLoading();
                    alert(tasksInfo);
                }
            } catch (error) {
                hideLoading();
                showStatus('Failed to load tasks: ' + error.message, 'error');
            }
        }

        // Event listeners
        applyBtn.addEventListener('click', applyModelChanges);
        refreshModelsBtn.addEventListener('click', refreshModels);
        refreshModelsListBtn.addEventListener('click', refreshModels);
        installMissingBtn.addEventListener('click', installMissingModels);
        refreshResourcesBtn.addEventListener('click', updateSystemResources);
        reindexBtn.addEventListener('click', startReindexing);

        // Model select change listeners
        chatModelSelect.addEventListener('change', () => {
            if (currentConfig && chatModelSelect.value !== currentConfig.current.chat_model) {
                applyBtn.disabled = false;
            }
        });

        embeddingModelSelect.addEventListener('change', () => {
            if (currentConfig && embeddingModelSelect.value !== currentConfig.current.embedding_model) {
                applyBtn.disabled = false;
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            // Show initial loading
            showLoading('Connecting to server...');
            
            // Check if server is responding with retry logic
            let serverReady = false;
            let retries = 3;
            
            while (retries > 0 && !serverReady) {
                try {
                    const response = await fetch('/health', { 
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (response.ok) {
                        serverReady = true;
                        hideLoading();
                        await loadConfiguration();
                        break;
                    }
                } catch (error) {
                    console.log(`Server check attempt ${4-retries} failed:`, error.message);
                    retries--;
                    
                    if (retries > 0) {
                        loadingText.textContent = `Waiting for server... Retrying in ${5 - retries} seconds`;
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
            }
            
            if (!serverReady) {
                hideLoading();
                showStatus(
                    'Server is not responding. Please ensure:<br>' +
                    '1. FastAPI is running (python app/main.py)<br>' +
                    '2. Port 8000 is not in use<br>' +
                    '3. Check server logs for errors<br>' +
                    '4. Try refreshing the page in a few seconds',
                    'error'
                );
                return;
            }
            
            // Load initial configuration
            await loadConfiguration();
            
            // Check for URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const updateStatus = urlParams.get('update');
            if (updateStatus === 'success') {
                showStatus('Models updated successfully!', 'success');
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            
            // Auto-refresh system resources every 10 seconds
            setInterval(updateSystemResources, 10000);
            
            // Auto-refresh active tasks every 5 seconds
            setInterval(checkActiveTasks, 5000);
            
            // Auto-refresh status every 30 seconds
            setInterval(checkSystemStatus, 30000);
        });

        // Expose functions to global scope for onclick handlers
        window.useModel = useModel;
        window.installModel = installModel;
        window.showDetailedMetrics = showDetailedMetrics;
        window.showActiveTasks = showActiveTasks;
    </script>
</body>
</html>
