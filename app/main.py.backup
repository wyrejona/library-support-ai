from fastapi import FastAPI, UploadFile, File, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.templating import Jinja2Templates
import os
import shutil
from datetime import datetime
from typing import List
import uvicorn
from pathlib import Path
import sys
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Add the app directory to Python path
current_file = Path(__file__).resolve()
app_dir = current_file.parent
project_root = app_dir.parent

sys.path.insert(0, str(app_dir))
sys.path.insert(0, str(project_root))

logger.info(f"Current directory: {current_file}")
logger.info(f"App directory: {app_dir}")
logger.info(f"Project root: {project_root}")

# Import our custom modules with fallbacks
VectorStore = None
OllamaClient = None

try:
    logger.info("Trying to import from app.utils and app.ai.llm...")
    from app.utils import VectorStore
    from app.ai.llm import OllamaClient
    logger.info("✓ Imported from app.*")
except ImportError as e:
    logger.warning(f"First import failed: {e}")
    try:
        logger.info("Trying to import from utils and ai.llm...")
        from utils import VectorStore
        from ai.llm import OllamaClient
        logger.info("✓ Imported from direct modules")
    except ImportError as e:
        logger.warning(f"Second import failed: {e}")
        try:
            logger.info("Trying relative imports...")
            from .utils import VectorStore
            from .ai.llm import OllamaClient
            logger.info("✓ Imported with relative imports")
        except ImportError as e:
            logger.error(f"All imports failed: {e}")
            logger.info("Creating dummy implementations...")
            
            # Dummy implementations
            class DummyVectorStore:
                def __init__(self, *args, **kwargs):
                    logger.warning("Using DummyVectorStore")
                def search(self, *args, **kwargs):
                    return []
                def load(self):
                    return False
            
            class DummyOllamaClient:
                def __init__(self, model="qwen:0.5b"):
                    logger.warning(f"Using DummyOllamaClient with model={model}")
                    self.model = model
                def generate_response(self, prompt, context):
                    return f"Dummy response to: {prompt}. Please check your imports and dependencies."
            
            VectorStore = DummyVectorStore
            OllamaClient = DummyOllamaClient

# Initialize components
try:
    vector_store = VectorStore()
    llm_client = OllamaClient(model="qwen:0.5b")
    logger.info("✓ Components initialized")
except Exception as e:
    logger.error(f"Failed to initialize components: {e}")
    # Use dummy implementations if initialization fails
    vector_store = VectorStore()
    llm_client = OllamaClient(model="qwen:0.5b")

app = FastAPI(title="Library Support AI")

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Get the current directory
current_dir = Path(__file__).parent

# Create necessary project directories
pdfs_dir = current_dir.parent / "pdfs"
data_dir = current_dir.parent / "data"
os.makedirs(pdfs_dir, exist_ok=True)
os.makedirs(data_dir, exist_ok=True)

logger.info(f"PDFs directory: {pdfs_dir}")
logger.info(f"Data directory: {data_dir}")

# Configure templates - they are in app/templates
templates_dir = current_dir / "templates"
logger.info(f"Templates directory: {templates_dir}")
if not templates_dir.exists():
    logger.warning(f"Templates directory does not exist! Creating...")
    os.makedirs(templates_dir, exist_ok=True)

templates = Jinja2Templates(directory=str(templates_dir))

def format_file_size(bytes):
    """Format file size in human readable format"""
    if bytes == 0:
        return "0 Bytes"
    size_names = ["Bytes", "KB", "MB", "GB", "TB"]
    i = 0
    while bytes >= 1024 and i < len(size_names) - 1:
        bytes /= 1024.0
        i += 1
    return f"{bytes:.2f} {size_names[i]}"

# ==================== ROUTES ====================

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Home page"""
    logger.info("GET / called")
    return templates.TemplateResponse("index.html", {"request": request})

# File Management Page - GET request returns HTML
@app.get("/files", response_class=HTMLResponse)
async def manage_files(request: Request):
    """File management page"""
    logger.info("GET /files called")
    
    # Get list of files
    files = []
    for f in os.listdir(pdfs_dir):
        if f.endswith(".pdf"):
            file_path = pdfs_dir / f
            files.append({
                "name": f,
                "size": os.path.getsize(file_path),
                "modified": datetime.fromtimestamp(os.path.getmtime(file_path)),
                "formatted_size": format_file_size(os.path.getsize(file_path))
            })
    
    # Sort files by modification time (newest first)
    files.sort(key=lambda x: x["modified"], reverse=True)
    
    # Get vector store status
    vector_status = "Not processed"
    if os.path.exists(data_dir / "chroma.sqlite3"):
        vector_status = "Ready"
    
    total_size = sum(f["size"] for f in files)
    
    logger.info(f"Returning {len(files)} files to template")
    return templates.TemplateResponse("files.html", {
        "request": request,
        "files": files,
        "total_files": len(files),
        "total_size": total_size,
        "format_file_size": format_file_size,
        "vector_status": vector_status
    })

# Chat Page - GET request returns HTML
@app.get("/chat", response_class=HTMLResponse)
async def chat_page(request: Request):
    """Chat page"""
    logger.info("GET /chat called")
    
    # Get list of files
    files = []
    for f in os.listdir(pdfs_dir):
        if f.endswith(".pdf"):
            file_path = pdfs_dir / f
            files.append({
                "name": f,
                "size": os.path.getsize(file_path),
                "formatted_size": format_file_size(os.path.getsize(file_path))
            })
    
    logger.info(f"Returning chat with {len(files)} files")
    return templates.TemplateResponse("chat.html", {
        "request": request,
        "files": files,
        "total_files": len(files)
    })

# Chat API - POST request returns JSON
@app.post("/chat")
async def chat_api(request_data: dict):
    """Chat API endpoint"""
    user_message = request_data.get("message") or request_data.get("query") or ""
    logger.info(f"POST /chat called with message: {user_message[:50]}...")
    
    if not user_message:
        return {"response": "Please enter a question."}
    
    try:
        # Search for relevant context
        search_results = vector_store.search(user_message, k=2)
        logger.info(f"Search returned {len(search_results)} results")
        
        try:
            from utils import format_context
            context = format_context(search_results)
        except ImportError:
            context = "\n".join([str(r) for r in search_results])
        
        # Generate response using LLM
        response = llm_client.generate_response(prompt=user_message, context=context)
        logger.info(f"Generated response length: {len(response)}")
        
        return {
            "response": response,
            "answer": response,
            "context_used": len(context) > 0
        }
    except Exception as e:
        logger.error(f"Chat error: {e}", exc_info=True)
        return {
            "response": f"I apologize, but I encountered an error: {str(e)}",
            "error": str(e)
        }

@app.post("/upload")
async def upload_files(files: List[UploadFile] = File(...)):
    """Upload PDF files"""
    uploaded_files = []
    
    for file in files:
        if file.filename.lower().endswith('.pdf'):
            file_path = pdfs_dir / file.filename
            with open(file_path, "wb") as buffer:
                shutil.copyfileobj(file.file, buffer)
            file_size = os.path.getsize(file_path)
            uploaded_files.append({
                "name": file.filename,
                "size": file_size,
                "uploaded_at": datetime.now().isoformat()
            })
    
    logger.info(f"Uploaded {len(uploaded_files)} files")
    return {"status": "success", "uploaded": uploaded_files}

@app.get("/api/files")
async def list_files_api():
    """API endpoint to list files"""
    files = []
    for f in os.listdir(pdfs_dir):
        if f.endswith(".pdf"):
            file_path = pdfs_dir / f
            files.append({
                "name": f,
                "size": os.path.getsize(file_path),
                "modified": datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat()
            })
    return {"files": files}

@app.get("/download/{filename}")
async def download_file(filename: str):
    """Download a file"""
    filepath = pdfs_dir / filename
    if os.path.exists(filepath):
        logger.info(f"Downloading file: {filename}")
        return FileResponse(
            path=filepath,
            filename=filename,
            media_type='application/pdf',
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
    logger.warning(f"File not found: {filename}")
    raise HTTPException(status_code=404, detail="File not found")

@app.delete("/files/{filename}")
async def delete_file(filename: str):
    """Delete a file"""
    path = pdfs_dir / filename
    if os.path.exists(path):
        os.remove(path)
        logger.info(f"Deleted file: {filename}")
        return {"status": "deleted", "filename": filename}
    logger.warning(f"File not found for deletion: {filename}")
    raise HTTPException(status_code=404, detail="File not found")

@app.delete("/clear-all-files")
async def clear_all_files():
    """Clear all files"""
    try:
        # Remove all PDF files
        for filename in os.listdir(pdfs_dir):
            if filename.endswith(".pdf"):
                os.remove(pdfs_dir / filename)
        
        # Optionally clear vector store data
        if os.path.exists(data_dir):
            shutil.rmtree(data_dir)
            os.makedirs(data_dir, exist_ok=True)
        
        logger.info("Cleared all files")
        return {"status": "success", "message": "All files cleared"}
    except Exception as e:
        logger.error(f"Error clearing files: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/ingest")
async def ingest_pdfs():
    """Process PDFs for vector store"""
    import subprocess
    try:
        # Run ingest.py from the parent directory
        ingest_script = project_root / "ingest.py"
        logger.info(f"Running ingest script: {ingest_script}")
        result = subprocess.run(["python3", str(ingest_script)], capture_output=True, text=True)
        if result.returncode == 0:
            logger.info("PDFs processed successfully")
            return {"success": True, "message": "PDFs processed successfully"}
        else:
            logger.error(f"Ingest failed: {result.stderr}")
            return {"success": False, "error": result.stderr}
    except Exception as e:
        logger.error(f"Error in ingest: {e}")
        return {"success": False, "error": str(e)}

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "pdfs_count": len([f for f in os.listdir(pdfs_dir) if f.endswith(".pdf")])
    }

# ==================== MAIN ====================

if __name__ == "__main__":
    logger.info("Starting server on http://0.0.0.0:8000")
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
